<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>랩틸리언을 찾아라 — 녹즙 조사</title>
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        min-height: 100vh;
        background: radial-gradient(circle at top, rgba(30, 41, 59, 0.9), #05070f 70%);
        font-family: "Pretendard", "Noto Sans KR", "Apple SD Gothic Neo", system-ui, -apple-system,
          BlinkMacSystemFont, "Segoe UI", sans-serif;
        color: #e2e8f0;
      }

      .page-wrap {
        display: flex;
        align-items: center;
        justify-content: center;
        min-height: 100vh;
        padding: 24px;
        box-sizing: border-box;
      }

      .game-shell {
        width: min(100%, 960px);
        background: rgba(15, 23, 42, 0.92);
        border: 1px solid rgba(148, 163, 184, 0.22);
        border-radius: 22px;
        padding: 32px 28px;
        box-shadow: 0 28px 80px rgba(15, 23, 42, 0.55);
      }

      .intro-wrap {
        text-align: center;
      }

      .intro-wrap h1 {
        margin: 0 0 18px;
        font-size: clamp(1.6rem, 2.2vw + 1rem, 2.6rem);
        font-weight: 600;
        color: #f8fafc;
        letter-spacing: -0.02em;
      }

      .intro-copy {
        font-size: clamp(1rem, 1vw + 0.8rem, 1.15rem);
        margin: 0 auto 24px;
        max-width: 640px;
        color: rgba(226, 232, 240, 0.85);
        line-height: 1.7;
      }

      .intro-meta {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 12px 20px;
        margin-bottom: 32px;
        font-size: 0.95rem;
        color: rgba(148, 163, 184, 0.9);
      }

      .intro-meta span {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 6px 12px;
        border-radius: 999px;
        border: 1px solid rgba(148, 163, 184, 0.35);
        background: rgba(15, 23, 42, 0.55);
      }

      .primary-button {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 10px;
        padding: 14px 28px;
        border-radius: 999px;
        border: none;
        font-size: 1.05rem;
        font-weight: 600;
        background: linear-gradient(135deg, #38bdf8, #6366f1);
        color: #0b1120;
        cursor: pointer;
        box-shadow: 0 12px 30px rgba(56, 189, 248, 0.35);
        transition: transform 120ms ease, box-shadow 120ms ease;
      }

      .primary-button:hover {
        transform: translateY(-1px);
        box-shadow: 0 16px 36px rgba(56, 189, 248, 0.45);
      }

      .primary-button:active {
        transform: translateY(0);
        box-shadow: 0 8px 20px rgba(56, 189, 248, 0.32);
      }

      .primary-button svg {
        width: 20px;
        height: 20px;
      }

      .game-section {
        margin-top: 32px;
      }

      .game-section.is-hidden {
        display: none;
      }

      @media (max-width: 640px) {
        .game-shell {
          padding: 24px 20px;
        }

        .intro-meta {
          flex-direction: column;
          gap: 10px;
        }
      }
    </style>
  </head>
  <body>
    <div class="page-wrap">
      <div class="game-shell">
        <div class="intro-wrap" id="intro-section">
          <h1>녹즙 출근부 — 잠입자 의심 신고서</h1>
          <p class="intro-copy">
            새벽마다 탕비실로 들어가 비밀리에 녹즙을 제조하는 동료가 있습니다. 오늘도 "정상 출근"
            이라는 명목으로 사무실 문을 열면, 곧장 의심스러운 동작을 추적해야 합니다. 버튼을 누르는
            순간부터는 후퇴할 수 없습니다.
          </p>
          <div class="intro-meta">
            <span>07:45 — 탕비실 문이 열리기 전</span>
            <span>증거 수집 단계 4회</span>
            <span>정신력 관리 필수</span>
          </div>
          <button type="button" class="primary-button" id="start-commute">
            출근하기
            <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path d="M5 12h14" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
              <path
                d="M13 6l6 6-6 6"
                stroke="currentColor"
                stroke-width="2"
                stroke-linecap="round"
                stroke-linejoin="round"
              />
            </svg>
          </button>
        </div>
        <div class="game-section is-hidden" id="game-section">
          <div id="game-root"></div>
        </div>
      </div>
    </div>
    <div id="intro-root"></div>
    <script src="./green-juice-game.js"></script>
    <script>
      (function () {
        function init() {
          const startButton = document.getElementById("start-commute");
          const introSection = document.getElementById("intro-section");
          const gameSection = document.getElementById("game-section");
          const root = document.getElementById("game-root");
          if (!gameSection || !root || !window.GreenJuiceLite) {
            return;
          }

          let started = false;

          function startExperience() {
            if (started) return;
            started = true;
            if (introSection) {
              introSection.classList.add("is-hidden");
            }
            gameSection.classList.remove("is-hidden");

            window.GreenJuiceLite.mount({
              container: root,
              onEnd(result) {
                console.log("Game Ended", result);
              },
            });
            window.GreenJuiceLite.start();
          }

          if (startButton) {
            startButton.addEventListener("click", startExperience);
          }

          window.addEventListener("greenjuice:introComplete", startExperience, { once: false });
        }

        if (document.readyState === "loading") {
          document.addEventListener("DOMContentLoaded", init);
        } else {
          init();
        }
      })();
    </script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script type="text/babel" data-presets="env,react">
      const { useMemo, useState, useEffect, useRef, useCallback } = React;

      function HeroIllust() {
        return (
          <svg
            viewBox="0 0 600 360"
            style={{
              width: "min(92vw, 820px)",
              maxWidth: 900,
              height: "auto",
              borderRadius: 16,
              border: "1px solid rgba(255,255,255,0.12)",
              background: "linear-gradient(180deg,#070a13,#0a0f1f)",
            }}
          >
            <defs>
              <linearGradient id="g1" x1="0" y1="0" x2="0" y2="1">
                <stop offset="0%" stopColor="#0f172a" />
                <stop offset="100%" stopColor="#0b1320" />
              </linearGradient>
              <pattern id="scales" width="10" height="10" patternUnits="userSpaceOnUse">
                <path d="M0,10 Q5,0 10,10" fill="none" stroke="#3fa66b" strokeWidth="1" />
              </pattern>
            </defs>
            <rect x="0" y="0" width="600" height="360" fill="url(#g1)" />
            <g transform="translate(300,180)">
              <ellipse cx="0" cy="0" rx="120" ry="140" fill="#e5e7eb" stroke="#0c1220" strokeWidth="4" />
              <line x1="0" y1="-140" x2="0" y2="140" stroke="#0c1220" strokeWidth="4" />
              <clipPath id="rightHalf">
                <rect x="0" y="-160" width="160" height="320" />
              </clipPath>
              <g clipPath="url(#rightHalf)">
                <ellipse cx="0" cy="0" rx="120" ry="140" fill="#0f3b33" />
                <ellipse cx="50" cy="-10" rx="26" ry="18" fill="#d6b410" stroke="#0b1220" strokeWidth="4" />
                <circle cx="58" cy="-10" r="6" fill="#0b1220" />
                <rect x="-120" y="-140" width="240" height="280" fill="url(#scales)" opacity="0.4" />
              </g>
              <clipPath id="leftHalf">
                <rect x="-160" y="-160" width="160" height="320" />
              </clipPath>
              <g clipPath="url(#leftHalf)">
                <ellipse cx="0" cy="0" rx="120" ry="140" fill="#cbd5e1" />
                <ellipse cx="-50" cy="-12" rx="22" ry="14" fill="#1e293b" />
                <circle cx="-52" cy="-12" r="5" fill="#93c5fd" />
              </g>
              <path d="M-30,50 Q0,70 30,50" stroke="#0b1220" strokeWidth="7" fill="none" strokeLinecap="round" />
            </g>
            <text
              x="300"
              y="330"
              textAnchor="middle"
              fill="#dee2e6"
              style={{ fontFamily: "ui-sans-serif", fontSize: 18, fontWeight: 800 }}
            >
              반은 인간, 반은 랩틸리언
            </text>
          </svg>
        );
      }

      function TitleScreen({ onStart }) {
        const introLines = useMemo(
          () => [
            "처음엔… 별거 아닌 줄 알았다.",
            "사람들이 말을 할 때, 눈을 깜빡이지 않는 순간이 있었다.",
            "탕비실에서는 녹즙 냄새가 너무 진하게 났고, 회의실에서는 누군가 입술을 핥는 소리가 났다.",
            "다들 평범한 동료들이었다. 적어도… 겉모습은.",
          ],
          [],
        );
        const finalLine = useMemo(() => "— 이 회사엔 분명 한 명 있다.\n\n인간이 아닌 자가..", []);
        const [introPhase, setIntroPhase] = useState("idle");
        const [lineIndex, setLineIndex] = useState(0);
        const [charIndex, setCharIndex] = useState(0);
        const [renderedLines, setRenderedLines] = useState(() => introLines.map(() => ""));
        const [hasIntroStarted, setHasIntroStarted] = useState(false);
        const audioRef = useRef(null);
        const typingAudioRef = useRef(null);
        const activeTypingAudiosRef = useRef([]);
        const [finalRendered, setFinalRendered] = useState("");
        const [finalCharIndex, setFinalCharIndex] = useState(0);
        const [finalTypingDone, setFinalTypingDone] = useState(false);
        const finalButtonDelayMs = 1000;

        const playTypingSound = useCallback(() => {
          const base = typingAudioRef.current;
          if (!base) return;
          const clone = base.cloneNode();
          clone.volume = 0.45;
          const sounds = activeTypingAudiosRef.current;
          const removeClone = () => {
            clone.removeEventListener("ended", removeClone);
            clone.removeEventListener("error", removeClone);
            const idx = sounds.indexOf(clone);
            if (idx >= 0) {
              sounds.splice(idx, 1);
            }
          };
          clone.addEventListener("ended", removeClone);
          clone.addEventListener("error", removeClone);
          sounds.push(clone);
          const playPromise = clone.play();
          if (playPromise && typeof playPromise.catch === "function") {
            playPromise.catch(() => {
              removeClone();
            });
          }
        }, []);

        useEffect(() => () => {
          const sounds = activeTypingAudiosRef.current;
          sounds.forEach((audio) => {
            try {
              audio.pause();
            } catch (err) {}
          });
          sounds.length = 0;
        }, []);

        useEffect(() => {
          if (introPhase !== "typing") return;

          if (lineIndex >= introLines.length) {
            const timeout = setTimeout(() => setIntroPhase("final"), 700);
            return () => clearTimeout(timeout);
          }

          const target = introLines[lineIndex];
          if (charIndex < target.length) {
            const timeout = setTimeout(() => {
              setRenderedLines((prev) => {
                const next = prev.slice();
                const current = next[lineIndex] || "";
                next[lineIndex] = current + target[charIndex];
                return next;
              });
              playTypingSound();
              setCharIndex((prev) => prev + 1);
            }, 45);
            return () => clearTimeout(timeout);
          }

          const timeout = setTimeout(() => {
            setLineIndex(lineIndex + 1);
            setCharIndex(0);
          }, 650);
          return () => clearTimeout(timeout);
        }, [introPhase, lineIndex, charIndex, introLines, playTypingSound]);

        useEffect(() => {
          const audioEl = audioRef.current;
          if (!audioEl) return;
          if (hasIntroStarted) {
            audioEl.currentTime = 0;
            audioEl.volume = 0.35;
            const playPromise = audioEl.play();
            if (playPromise && typeof playPromise.catch === "function") {
              playPromise.catch(() => {});
            }
          } else {
            audioEl.pause();
            audioEl.currentTime = 0;
          }
          return () => {
            audioEl.pause();
            audioEl.currentTime = 0;
          };
        }, [hasIntroStarted]);

        useEffect(() => {
          if (introPhase !== "final") return;
          setFinalRendered("");
          setFinalCharIndex(0);
          setFinalTypingDone(false);
        }, [introPhase, finalLine]);

        useEffect(() => {
          if (introPhase !== "final") return;
          if (finalTypingDone) return;
          if (finalCharIndex < finalLine.length) {
            const timeout = setTimeout(() => {
              setFinalRendered((prev) => prev + finalLine[finalCharIndex]);
              playTypingSound();
              setFinalCharIndex((prev) => prev + 1);
            }, 55);
            return () => clearTimeout(timeout);
          }
          const timeout = setTimeout(() => setFinalTypingDone(true), finalButtonDelayMs);
          return () => clearTimeout(timeout);
        }, [introPhase, finalCharIndex, finalLine, finalTypingDone, playTypingSound]);

        const handlePrimaryClick = () => {
          if (!hasIntroStarted) {
            setHasIntroStarted(true);
            setRenderedLines(introLines.map(() => ""));
            setLineIndex(0);
            setCharIndex(0);
            setIntroPhase("typing");
            return;
          }

          if (introPhase === "idle") {
            onStart?.();
          }
        };

        const overlayVisible = introPhase === "typing" || introPhase === "final";
        const buttonLabel = hasIntroStarted ? "게임 시작" : "START";
        const buttonDisabled = introPhase === "typing" || introPhase === "final";

        return (
          <div style={styles.titleRoot}>
            <audio ref={audioRef} src="./BGM_01.mp3" loop preload="auto" style={{ display: "none" }} />
            <audio ref={typingAudioRef} src="./writing_01.mp3" preload="auto" style={{ display: "none" }} />
            <HeroIllust />
            <div style={styles.titleBox}>
              <div style={{ fontWeight: 900, fontSize: 28, letterSpacing: 1 }}>랩틸리언을 찾아라</div>
              <div style={{ opacity: 0.9, marginTop: 6 }}>반은 인간, 반은 랩틸리언… 오늘도 평범한 회사?</div>
              <button
                style={{
                  ...styles.btnPrimary,
                  opacity: buttonDisabled ? 0.7 : 1,
                  cursor: buttonDisabled ? "default" : "pointer",
                }}
                onClick={handlePrimaryClick}
                disabled={buttonDisabled}
              >
                {buttonLabel}
              </button>
            </div>
            {overlayVisible && (
              <div
                style={{
                  ...styles.introOverlay,
                  backgroundColor: introPhase === "final" ? "rgba(6,9,17,0.92)" : "rgba(4,6,14,0.96)",
                  pointerEvents: "auto",
                }}
              >
                {hasIntroStarted && (
                  <button
                    onClick={() => onStart?.()}
                    style={{
                      position: "absolute",
                      top: 24,
                      right: 28,
                      padding: "8px 16px",
                      fontWeight: 700,
                      fontSize: 14,
                      borderRadius: 999,
                      border: "1px solid rgba(255,255,255,0.3)",
                      background: "rgba(15,23,42,0.7)",
                      color: "#f8fafc",
                      cursor: "pointer",
                      boxShadow: "0 6px 18px rgba(0,0,0,0.35)",
                    }}
                  >
                    Skip
                  </button>
                )}
                {introPhase === "typing" ? (
                  <div style={styles.introBox}>
                    {introLines.map((line, idx) => {
                      const text = renderedLines[idx] || (idx < lineIndex ? line : "");
                      if (!text) return null;
                      return (
                        <div key={idx} style={styles.introLine}>
                          {text}
                        </div>
                      );
                    })}
                  </div>
                ) : (
                  <div style={styles.introFinalBox}>
                    <div style={styles.introFinalLineGroup}>
                      {finalRendered.split("\n").map((line, idx, arr) => {
                        if (!line.trim()) {
                          return <div key={idx} style={{ height: idx === arr.length - 1 ? 0 : 16 }} />;
                        }
                        const trimmed = line.trim();
                        const targetFinalLine = "인간이 아닌 자가..";
                        const highlight = targetFinalLine.startsWith(trimmed) || trimmed.startsWith(targetFinalLine);
                        return (
                          <div
                            key={idx}
                            style={{
                              ...styles.introFinalLine,
                              ...(highlight ? styles.introFinalLineEmphasis : null),
                            }}
                          >
                            {line}
                          </div>
                        );
                      })}
                    </div>
                    <button
                      style={{
                        ...styles.btnPrimary,
                        opacity: finalTypingDone ? 1 : 0,
                        pointerEvents: finalTypingDone ? "auto" : "none",
                        transform: finalTypingDone ? "translateY(0)" : "translateY(12px)",
                        transition: "opacity 0.6s ease, transform 0.6s ease",
                      }}
                      onClick={() => onStart?.()}
                    >
                      출근하기
                    </button>
                  </div>
                )}
              </div>
            )}
          </div>
        );
      }

      function IntroApp({ onComplete }) {
        const [dismissed, setDismissed] = useState(false);

        const handleStart = useCallback(() => {
          if (dismissed) return;
          setDismissed(true);
          onComplete?.();
        }, [dismissed, onComplete]);

        if (dismissed) {
          return null;
        }

        return (
          <div
            style={{
              position: "fixed",
              inset: 0,
              zIndex: 120,
              background: "radial-gradient(900px 400px at 50% 0%, #0a0e1a, #070a13)",
            }}
          >
            <TitleScreen onStart={handleStart} />
          </div>
        );
      }

      function renderIntroOverlay() {
        const container = document.getElementById("intro-root");
        if (!container) return;
        const root = ReactDOM.createRoot(container);
        const handleComplete = () => {
          root.unmount();
          const event = new CustomEvent("greenjuice:introComplete");
          window.dispatchEvent(event);
        };
        root.render(<IntroApp onComplete={handleComplete} />);
      }

      const styles = {
        titleRoot: {
          minHeight: "100vh",
          display: "grid",
          placeItems: "center",
          padding: 16,
          boxSizing: "border-box",
          background: "radial-gradient(900px 400px at 50% 0%, #0a0e1a, #070a13)",
          color: "#e5e7eb",
          position: "relative",
          overflow: "hidden",
        },
        titleBox: { textAlign: "center", marginTop: 16 },
        btnPrimary: {
          padding: "10px 14px",
          background: "#10b981",
          color: "#0b1020",
          border: "none",
          borderRadius: 10,
          fontWeight: 800,
          cursor: "pointer",
          marginTop: 12,
        },
        introOverlay: {
          position: "fixed",
          inset: 0,
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          padding: "0 24px",
          zIndex: 20,
          color: "#f8fafc",
          textAlign: "left",
          transition: "opacity 0.9s ease, filter 0.9s ease, background-color 0.9s ease",
        },
        introBox: {
          width: "min(760px,92vw)",
          display: "grid",
          gap: 18,
          fontSize: 20,
          lineHeight: 1.9,
          fontWeight: 600,
          fontFamily: "'Nanum Gothic Coding','Fira Mono',monospace",
        },
        introLine: { letterSpacing: 0.2 },
        introFinalBox: { width: "min(640px,88vw)", display: "grid", gap: 28, textAlign: "center" },
        introFinalLineGroup: { display: "grid", justifyItems: "center", gap: 4 },
        introFinalLine: { fontSize: 28, fontStyle: "italic", fontWeight: 800, lineHeight: 1.7, letterSpacing: 0.4 },
        introFinalLineEmphasis: { color: "#ef4444", fontSize: 34, fontStyle: "normal", fontWeight: 900, letterSpacing: 0.6 },
      };

      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", renderIntroOverlay, { once: true });
      } else {
        renderIntroOverlay();
      }
    </script>
  </body>
</html>
